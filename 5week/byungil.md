# 4. 조인 튜닝

# 4.1 NL 조인

## 4.1.1 기본 메커니즘

- 일반적으로 NL 조인은 Outer 와 Inner 양쪽 테이블 모두 인덱스를 이용한다.
- Outer 테이블은 사이즈가 크지 않거나 또는 Table Full Scan을 해도 한 번에 그치므로 인덱스를 사용하지 않을 수 있다.
- 하지만 `Inner 테이블` Outer 루프를 읽는 건수만큼 반복되므로 인덱스를 반드시 사용해야 한다.

## 4.1.2 NL 조인 실행계획 제어

- p.260

## 4.1.3 NL 조인 수행 과정 분석

- p.261

## 4.1.4 NL 조인 튜닝 포인트

- 테이블 랜덤 액세스를 줄여야 한다.
- 조인 액세스 횟수를 줄여야 한다.
- 맨 처음 액세스하는 인덱스에서 얻은 결과 건수에 의해 전체 일량이 좌우된다.

### 올바른 조인 메소드 선택

- 온라인 트랜잭션 처리(OLTP) 시스템에서 튜닝할 때 NL 조인부터 고려하는 것이 올바른 순서다.
- 성능이 느리다면, 조인 튜닝 포인트에 따라 각 단계의 수행 일량을 분석해서 과도한 랜덤 액세스가 발생하는 지점을 파악한다.
    - 조인 순서를 변경해서 랜덤 액세스 줄일 수 있는지
    - 더 효과적은 다른 인덱스가 있는지
    - 인덱스 추가 또는 구성 변경을 고려한다.
- 소트 머지 조인, 해시 조인을 검토한다.

## 4.1.5 NL 조인 특징 요약

- 랜덤 액세스 위주의 조인 방식이다.
    - 레코드를 하나를 읽으려고 블록을 통째로 읽는 랜덤 액세스 방식 (메모리 버퍼에서 빠르게 읽더라고 비효율 존재)
    - 대량 데이터 조인할 때 NL 조인이 불리한 이유다.
- 한 레코드씩 순차적으로 진행한다.
    - 첫 번째 특징 때문에 대량 데이터 처리 시 매우 치명적인 한계 드러낸다.
    - 반대로 이 두 번째 특징 때문에 아무리 큰 테이블을 조인하더라도 매우 바른 응답 속도를 낼 수 있다. (부분범위 처리가 가능한 상황에서)
    - 부분범위 처리를 활용하면 매우 빠른 응답속도
- 온라인 트랜잭션 처리(OLTP) 시스템에 적합한 조인 방식이다.

## 4.1.6 NL 조인 튜닝 실습

- p.266

## 4.1.7 NL 조인 확장 메커니즘

- 테이블 Prefetch
    - 인덱스를 이용해 테이블을 액세스하다가 디스크 I/O가 필요해지면, 이어서 곧 읽게 될 블록까지 미리 읽어서 버퍼캐시에 적재하는 기능이다.
- 배치 I/O
    - 디스크 I/O Call을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리하는 기능이다.
- 두 기능 모두, 읽는 블록마다 건건이 I/O Call을 발생시키는 비효율을 줄인다.

---

# 4.2 소트 머지 조인

- 조인 컬럼에 인덱스가 없을 때
- 대량 데이터 조인이어서 인덱스가 효과적이지 않을 때 활용한다.

## 4.2.1 SGA vs PGA

- 공유 메모리 영역인 SGA에 캐시된 데이터는 여러 프로세스가 공유할 수 있다.
    - 공유는 할 수 있지만, 동시에 액세스할 수는 없다.
    - 동시에 액세스하려는 프로세스 간 액세스를 직렬화하기 위한 Lock 메커니즘으로서 래치(Latch)가 존재한다.
    - 데이터블록과 인덱스 블록을 캐싱하는 DB 버퍼캐시는 SGA의 가장 핵심적인 구성요소이며, 블록을 읽으려면 버퍼 Lock도 얻어야 한다. (1.3.8 참고)
- 오라클 서버 프로세스는 SGA에 공유된 데이터를 읽고 쓰면서, 동시에 자신만의 고유 메모리 영역을 갖는다.
- 각 오라클 서버 프로세스에 할당된 메모리 영역을 PGA(Process/Program/Private Global Area)라고 부르며, 프로세스에 종속적인 고유 데이터를 저장하는 용도로 사용한다.
- 할당받은 PGA 공간이 작아 데이터를 모두 저장할 수 없을 때는 Temp 테이블스페이스를 이용한다.
- PGA는 다른 프로세스와 공유하지 않는 독립적인 메모리 공간이므로 래치 메커니즘이 불필요하다.
- 따라서 같은 양의 데이터를 읽더라도 SGA 버퍼캐시에서 읽을 때보다 훨씬 빠르다.

## 4.2.2 기본 메커니즘

### 소트 단계: 양쪽 집합을 조인 컬럼 기준으로 정렬한다.

- 한 쪽 테이블을 조인컬럼 기준으로 정렬한다.
- 반대쪽 테이블도 조인컬럼 기준으로 정렬한다.
- 정렬한 결과집합은 PGA 영역에 할당된 Sort Area에 저장한다. PGA에 담을 수 없을 정도로 크면, TEMP 테이블스페이스에 저장한다.

### 머지 단계: 정렬한 양쪽 집합을 서로 머지(Merge)한다.

- PGA(또는 Temp 테이블스페이스)에 저장한 사원 데이터를 스캔하면서 PGA에 저장한 고객 데이터와 조인한다.

## 4.2.3 소트 머지 조인이 빠른 이유

- NL 조인은 인덱스를 이용한 조인 방식이다. 인덱스를 이용하기 때문에 인덱스 손익분기점 한계를 그대로 드러낸다. → 대량 데이터 조인에 NL 조인이 불리한 이유
- 양쪽 테이블로부터 조인 대상 집합을 일괄적으로 읽어 PGA에 저장한 후 조인한다.
- PGA는 프로세스만을 위한 독립적인 메모리 공간이므로 데이터를 읽을 때 래치 획득 과정이 없다. → 대량 데이터 조인에 유리한 이유다.
- 소트 머지 조인도 양쪽 테이블로부터 조인 대상 집합을 읽을 때는 DB 버퍼캐시를 경유한다.
    - 이 때 인덱스를 이용하기도 한다.
    - 이 과정에서 생기는 버퍼캐시 탐색 비용과 랜덤 액세스 부하는 소트 머지 조인도 피할 수 없다.

## 4.2.4 소트 머지 조인의 주용도

- 조인 조건식이 등치(=) 조건이 아닌 대량 데이터 조인
- 조인 조건식이 아예 없는 조인(Cross Join, 카테시안 곱)

## 4.2.5 소트 머지 조인 제어하기

```sql
select /*+ ordered use_merge(c) */
        e.사원번호, e.사원명, e.입사일자, 
        c.고객번호, c.고개명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.관리사원번호 = e.사원번호
and e.입사일자 >= '19960101'
and e.부서코드 = 'Z123'
and c.최조주문금액 >= 20000
```

## 4.2.6 소트 머지 조인 특징 요약

- 인덱스 유무에 크게 영향을 받지 않는다.
- 양쪽 집합을 개별적으로 읽고 나서 조인을 시작한다.
- 조인 컬럼에 인덱스가 없는 상황에서 두 테이블을 각각 읽어 조인 대상 집합을 줄일 수 있다.
- 스캔 위주의 액세스 방식을 사용한다.
    - 하지만 모든 처리가 스캔 방식으로 이루어지진 않는다.
    - 양쪽 소스 집합으로부터 조인 대상 레코드를 찾는 데 인덱스를 이용할 수 있고, 그 때는 랜덤 액세스가 일어난다.

---

# 4.3 해시 조인

- NL 조인은 인덱스를 이용한 조인 방식이므로 인덱스 구성에 따른 성능 차이가 심하다.
- 소트 머지 조인은 항상 양쪽 테이블을 정렬하는 부담이 있다.
- 그렇다고 모든 조인을 해시 조인으로 처리할 수는 없다.
- 각 조인 방식의 특성을 정확히 이해함으로써 상황에 맞게 선택하는 것이 중요하다.

## 4.3.1 기본 메커니즘

### Build 단계: 작은 쪽 테이블(Build input)을 읽어 해시 테이블(해시 맵)을 생성

- 조건에 해당하는 데이터를 읽어 해시 테이블을 생성한다. 이때, 조인컬럼을 해시 테이블 키 값으로 사용한다.
- 즉 조인컬럼을 해시 함수에 입력해서 반환된 값으로 해시 체인을 갖고, 그 해시 체인에 데이터를 연결한다.
- 해시 테이블은 PGA 영역에 할당된 Hash Area에 저장한다. (해시 테이블이 크면 Temp에 저장)

### Prob 단계: 조건에 해당하는 데이터를 하나씩 읽어 해시 테이블을 탐색한다.

- 조인컬럼을 해시 함수에 입력해서 반환된 값으로 해시 체인을 갖고, 그 해시 체인을 스캔해서 값이 같은 조인컬럼을 찾는다.
- 찾으면 조인에 성공한 것이고, 못 찾으면 실패한 것이다.

## 4.3.2 해시 조인이 빠른 이유

- Hash Area에 생성한 해시 테이블(=해시 맵)을 이용한다는 점만 다를 뿐 해시 조인도 조인 프로세싱 자체는 NL 조인과 같다.
- 해시 조인이 인덱스 기반의 NL 조인보다 빠른 결정적인 이유는 소트 머지 조인이 빠른 이유와 같다.
- 해시 테이블을 PGA 영역에 할당하기 때문이다.
    - 해시 조인은 래치 획득 과정 없이 PGA에서 빠르게 데이터를 탐색하고 조인한다.
- 해시 조인도 Build Input과 Prob Input 각 테이블을 읽을 때는 DB 버퍼캐시를 경유한다.
- 인덱스를 이용하기도 한다.
- 이 과정에서 생기는 버퍼캐시 탐색 비용과 랜덤 액세스 부하는 해시 조인이라도 피할 수 없다.

### 소트 머지 조인보다 더 빠른 이유

- 소트 머지 조인은 양쪽 집합을 모두 정렬해서 PGA 담는다.
- 어느 하나가 중대형 이상이면, Temp 테이블스페이스, 즉 디스크에 쓰는 작업을 반드시 수반한다.
- 해시 조인에서는 `한쪽`을 읽어 해시 맵을 만든다.
- 해시 조인은 NL 조인처럼 조인 과정에서 발생하는 랜덤 액세스 부하가 없고, 소트 머지 조인처럼 양쪽 집합을 미리 정렬하는 부하도 없다.
- 대량 데이터 조인할 때는 일반적으로 해시 조인이 가장 빠르다.

## 4.3.3 대용량 Build Input 처리

### 파티션 단계

- 조인하는 양쪽 집합의 조인 컬럼에 해시 함수를 적용하고, 반환된 해시 값에 따라 동적으로 파티셔닝한다.
- 독립적으로 처리할 수 있는 여러 개의 작은 서브 집합으로 분할함으로써 파티션 짝(pair)을 생성하는 단계다.
- 양쪽 집합을 디스크 Temp 공간에 저장해야 하므로 인메모리 해시 조인보다 성능이 많이 떨어진다.

### 조인 단계

- 파티션 단계를 완료하면 각 파티션 짝(pair)에 대해 하나씩 조인을 수행한다.
- 이때, 각각에 대한 Build Input과 Probe Input은 독립적으로 결정된다.
- 즉 파티션하기 전 어느 쪽이 작은 테이블이었는지에 상관없이 각 파티션 짝별로 작은 쪽을 Build Input으로 선택하고 해시 테이블을 생성한다.
- 해시 테이블을 생성하고 나면 반대쪽 파티션 로우를 하나씩 읽으면서 해시 테이블을 탐색한다.
- 모든 파티션 짝에 대한 처리를 마칠 때까지 이 과정을 반복한다.

## 4.3.4 해시 조인 실행계획 제어

- 위쪽 데이터(Build Input)로 해시 테이블을 생성한 후, 아래쪽 테이블(Prob Input)에서 읽은 조인 키값으로 해시 테이블을 탐색하면서 조인한다.
- 인덱스를 이용할 수 있고, 인덱스 없이 Table Full Scan으로 처리할 수 있다.

## 4.3.5 조인 메소드 선택 기준

- `수행빈도가 매우 높은 쿼리에서 사용하면 안 된다.`
- 소량 데이터 조인할 때 → NL 조인
    - 소량과 대량의 기준은 데이터량의 많고 적음에 있지 않다.
    - NL 조인 기준으로 `최적화했는데도` 랜덤 액세스가 많아 만족할만한 성능을 낼 수 없다면, 대량 데이터 조인에 해당한다.
- 대량 데이터 조인할 때 → 해시 조인
- 대량 데이터 조인인데 해시 조인으로 처리할 수 없을 때, 즉 조인 조건식이 등치(=) 조건이 아닐 때 → 소트 머지 조인
- NL 조인과 해시 조인 성능이 같다면 → NL 조인
- 해시 조인이 약간 더 빨라도 → NL 조인
- NL 조인보다 해시 조인이 매우 빠른 경우 → 해시 조인

### 왜 NL 조인을 가장 먼저 고려할까?

- NL 조인 위주로 처리하려면 인덱스를 세심하게 설계해야 하는 부담이 있는데 왜?
- NL 조인에 사용하는 인덱스는 영구적으로 유지하면서 다양한 쿼리를 위해 공유 및 재사용하는 자료구조다.
- 반면, 해시 테이블은 `단 하나의 쿼리를 위해 생성하고 조인이 끝나면 곧바로 소멸하는 자료구조다.`
- 같은 쿼리를 100개 프로세스가 동시에 수행하면, 해시 테이블도 100개가 만들어진다.
- 따라서 ㅅ행시간이 짧으면서 수행빈도가 매우 높은 쿼리(OLTP성 쿼리의 특징이기도 함)를 해시 조인으로 처리하면 CPU와 메모리 사용률이 크게 증가한다.
- 해시 맵을 만드는 과정에서 여러 가지 래치 경합도 발생한다.
- 결론적으로 해시 조인은 아래 세 가지 조건을 만족하는 SQL문에 주로 사용한다.
    - 수행 빈도가 낮고
    - 쿼리 수행 시간이 오래 걸리는
    - 대량 데이터 조인할 때

---

# 4.4 서브쿼리 조인

## 4.4.1 서브쿼리 변환이 필요한 이유

- 옵티마이저는 비용(Cost)을 평가하고 실행계획을 생성하기에 앞서 SQL을 최적화에 유리한 형태로 변환하는 작업, 즉 쿼리 변환부터 진행한다.
- 쿼리 변환은 옵티마이저가 SQL을 분석해 의미적으로 동일하면서도 더 나은 성능이 기대되는 형태로 재작성하는 것을 말한다.
- 옵티마이저는 쿼리 블록 단위로 최적화를 수행한다.

## 4.4.2 서브쿼리와 조인

- 메인쿼리와 서브쿼리 간에는 부모와 자식이랑은 종속적이고 계층적인 관계가 존재한다.
- 서브쿼리는 메인쿼리에 종속되므로 단독 실행할 수 없다.
- 메인쿼리 건수만큼 값을 받아 반복적으로 필터링하는 방식으로 실행해야 한다.

### 필터 오퍼레이션

- 서브쿼리를 필터 방식으로 처리할 때 사용한다.
- NL 조인과 처리 루틴이 같다. NL 조인처럼 부분 범위 처리도 가능하다.
- 차이가 있다면 필터는 메인쿼리의 한 로우가 서브쿼리의 한 로우와 조인에 성공하는 순간 진행을 멈추고, 메인쿼리의 다음 로우를 계속 처리한다.
- 이렇게 처리해야 메인쿼리 결과집합이 서브쿼리 M쪽 집합 수준으로 확장되는 현상(중복)을 막을 수 있다.
- 필터 캐싱기능을 갖는다.
- 메인쿼리에 종속되므로 조인 순서가 고정된다. 항상 메인쿼리가 드라이빙 집합이다.

### 서브쿼리 Unnesting

- 일반 조인문처럼 다양한 최적화 기법을 사용할 수 있다.
- Unnesting된 서브쿼리는 메인쿼리 집합보다 먼저 처리될 수 있다.
- 다양한 조인 메소드를 선택할 수 있고, 조인 순서도 마음껏 정할 수 있다.

### 서브쿼리 Pushing

- 서브쿼리 필터링을 가능한 한 앞 단계에서 처리하도록 강제하는 기능이다.
- Unnesting 되지 않은 서브쿼리에만 작동한다.

## 4.4.3 뷰(View)와 조인

- 최적화 단위가 쿼리 블록이므로 옵티마이저가 뷰(View) 쿼리를 변환하지 않으면 뷰 쿼리 블록을 독립적으로 최적화한다.
- 외부 조건과 관계 없이 인라인 뷰에 해당하는 모든 데이터를 읽어야 할 수도 있다.
    - 뷰 머징을 통해 메인 쿼리와 머지하면 외부 조건에 해당하는 만큼만 데이터를 읽을 수 있다.

### 조인 조건 Pushdown

- 메인 쿼리를 실행하면서 조인 조건절 값을 건건이 뷰 안으로 밀어 넣는 기능이다.
- 부분범위 처리가 가능하다.

## 4.4.4 스칼라 서브쿼리 조인

- select 쿼리를 품은 사용자 함수가 있다면 쿼리 건수만큼 재귀적으로 반복 실행된다.
- 하지만 스칼라 서브쿼리는 정확히 하나의 값만 반환한다.
- 함수처럼 재귀적이지 않으면서 컨텍스트 스위칭도 발생하지 않는다.

### 스칼라 서브쿼리 캐싱 효과

- 조인 횟수 최소화 할 수 있다.
- 쿼리를 시작할 때 PGA 메모리에 공간을 할당하고 수행하면서 마치는 순간 반환한다.

### 스칼라 서브쿼리 캐싱 부작용

- 입력 값의 종류가 적어서 해시 충돌 가능성이 적을 때 효과가 있다. 충돌이 많다면 당연히 성능이 낮아진다.
- 메인 쿼리 집합이 매우 작은 경우 메인쿼리 집합이 클수록 재사용성이 높아서 캐싱 효율이 좋다.

### 두 개 이상의 값 반환

- NL 조인 처럼 처리되기 때문에 부분범위 처리도 가능하고 캐싱의 효과를 쓸 수도 있어서 좋아보이지만 스칼라 서브쿼리는 두 개 이상의 값을 반환할 수가 없는 문제가 있다.

### Unnesting

- 스칼라 서브쿼리도 NL 방식 조인이다.
- 캐싱 효과가 크지 않을 경우 랜덤 I/O 부담이 있다.
- 다른 조인 방식을 선택하려면 스칼라 서브쿼리를 Unnesting 해서 일반 조인문으로 변환해야 한다.
- 병렬 쿼리는 해시 조인으로 처리해야 효과적이다.