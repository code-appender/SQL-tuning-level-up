# 3. 인덱스 튜닝(3.3 ~)

## 3.3.3 액세스 조건과 필터 조건

- 인덱스 액세스 조건
    - 인덱스 스캔 범위를 결정하는 조건절이다.
    - 인덱스 수직적 탐색을 통해 스캔 시작과 종료 지점을 결정하는 데 영향을 미친다.
- 인덱스 필터 조건
    - 테이블로 액세스할지 결정하는 조건절이다.
- 테이블 필터 조건
    - 쿼리 수행 다음 단계로 전달하거나 최종 결과 집합에 포함할지를 결정한다.

## 3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성

- 선행 컬럼인 `=` 일때 데이터는 군집되어 있다.
- 중간 컬럼이 범위 검색인 경우 그 뒤 레코드들은 흩어지게 된다.(해당 범위 내에서 - 결국 범위 증가)
- 선행 컬럼이 `=` 조건인 상태에서 첫 번째 나타나는 범위검색 조건이 인덱스 스캔 범위를 결정한다.
    - 첫 번째 나타나는 범위 검색까지 인덱스 액세스 조건, 나머지 컬럼 조건은 인덱스 필터 조건이다.

## 3.3.5 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율

- 인덱스 스캔 효율성은 인덱스 컬럼을 조건절에 모두 등치(=) 조건으로 사용할 때 가장 좋다.
    - 리프 블록을 스캔하면서 읽은 레코드는 하나도 걸러지지 않고 모두 테이블 액세스로 이어지므로 인덱스 스캔 단계에서의 비효율은 전혀 없다.
- 인덱스 컬럼 중 일부가 조건절에 없거나 등치 조건이 아니더라도, 그것이 뒤쪽 컬럼일 때는 비효율이 없다.
- 인덱스 선행 컬럼이 조건절에 없거나 부등호, BETWEEN, LIKE 같은 범위검색 조건이면, 인덱스를 스캔하는 단계에서 비효율이 생긴다.

## 3.3.6 BETWEEN을 IN-List로 전환

- 각각의 수직적 탐색을 통해 효율을 증가시킬 수 있다.
    - BETWEEN ‘1’ and ‘3’ 은 1과 3사이를 다 스캔한다. (2는 전체 스캔)
    - IN (’1’, ‘2’, ‘3’)은 1, 2, 3 수직적 탐색 세번이 발생한다.
- BETWEEN을 `=`로 바꾸고 union all로 합친다고 생각하면 된다.
- Index Skip Scan 방식과 비슷하다.

### BETWEEN 조건을 IN_List로 전환시 주의사항

- IN-List 개수가 많지 않아야 한다.
- 루트에서 브랜치 블록까지 Dpeth가 깊을 수록 비효율적이다.
- 레코드들이 서로 멀리 떨어져 있을 때 유용하다.
- 인덱스 블록이 소량일 때, IN-List로 변환하면 블록 I/O가 더 많이 발생한다.

## 3.3.7 Index Skip Scan 활용

- 선두 컬림이 BETWEEN 이어서 나머지 검색 조건을 만족하는 데이터들이 서로 멀리 떨어져 있을때, Index Skip Scan 이 유용할 수 있다.
- In List 방식을 안쓰고 BETWEEN 을 선두 컬럼으로 사용하면 스캔량이 많아진다.

## 3.3.8 IN 조건은 ‘=’ 인가

- IN 조건은 ‘=’ 이 아니다
- 데이터가 군집되어 있으면 IN-List 방식이 더 많은 I/O 를 반복적으로 발생시킬 수 있다.
  (리프 노드에는 많은 데이터가 존재)
- 3번이면 될거를 3번의 수직적 탐색을 통해 9번으로 뻥튀기 될 수도 있다.
- `NUM_INDEX_KEYS` 를 통해 액세스 조건 또는 필터 조건으로 유도하는방법도 존재한다.(p207 ~ p208)

## 3.3.9 BETWEEN과 LIKE 스캔 범위 비교

- BETWEEN이 LIKE보다 효율적이다. (손해 안 봄)
- 둘 다 범위검색 조건이다.
- LIKE는 ‘2019%’ 이라고 가정하면 ‘201913’ 가능성을 배제할 수 없어 범위가 넓어진다.

## 3.3.10 범위검색 조건을 남용할 때 생기는 비효율

- 인덱스 컬럼에 범위검색 조건을 남용할 경우 인덱스 스캔 비효율이 생긴다.
- p213 참고

## 3.3.11 다양한 옵션 조건 처리 방식의 장단점 비교

### OR 조건 활용

- 인덱스 선두 컬럼에 대한 옵선 져곤에 OR 조건을 사용하면 안 된다.
- 테이블 필터 조건으로만 사용하자.
- 유일한 장점은 옵선 조건 컬럼이 NULL 허용 컬럼이더라도 결과 집합을 보장한다는 것 뿐이다.

### LIKE/BETWEEN 조건 활용

- 변별력이 좋은 필수 조건이 있는 상황(당일 등록 상품은 소수)에서 사용하면 나쁘지 않다.
- 필수 조건 컬럼을 인덱스 선두에 두고 액세스 조건으로 사용하면, LIKE/BETWEEN이 인덱스 필터 조건이어도 충분히 좋은 성능을 낼 수 있다.
- 변별력이 좋지 않은 경우에는 오히려 Table Full Scan이 유리할 수 있다.

### 주의사항

- 인덱스 선두 컬럼에 대한 옵션 조건을 LIKE/BETWEEN 연산자로 처리하면 안 된다.
    - 고객 ID가 입력되지 않으면 모든 거래 데이터를 스캔하면서 거래 일자 조건을 필터링하는 불상사가 생긴다.

```sql
select *
from 거래
where 고객ID like :cust_id || '%'
and 거래일자 between :dt1 and :dt2
```

- NULL 허용 컬럼에 대한 옵션 조건을 LIKE/BETWEEN 연산자로 처리하면 안 된다.
    - 성능을 떠나 결과 집합에 오류가 생긴다.
    - 고객ID가 NULL 허용 컬럼이고 NULL 값이 입력돼 있다면 결과집합에서 누락된다.
- 숫자형이면서 인덱스 액세스 조건으로도 사용 가능한 컬럼에 대한 옵션 조건 처리는 LIKE 방식을 사용해선 안 된다.
    - 자동 형변환이 일어나므로 인덱스를 사용할 수 없다.
- LIKE를 옵션 조건에 사용할 때는 컬럼 값 길이가 고정적이어야 한다.
    - 기대하지 않은 데이터가 나올 수 있다. like ‘김훈%’ 에서 ‘김훈남’도 검색된다.

### UNION ALL 활용

- 특정 값 입력 유무에 따라 SQL 하나만 실행되게 한다. p.220
- 옵션 조건 컬럼도 인덱스 액세스 조건으로 사용한다는 사실이 중요하다.
- 유일한 단점은 SQL 코딩량이 길어진다.

# 3.4 인덱스 설계

## 3.4.1 인덱스 설계가 어려운 이유

- 인덱스를 생성하다 보면 관리비용, 시스템 부하를 증가시키는 요인이 된다.
- DML 성능 저하(TPS 저하)
- 데이터베이스 사이즈 증가
- 데이터베이스 관리 및 운영 비용 상승

## 3.4.2 가장 중요한 두 가지 선택 기준

- 인덱스 선두 컬럼을 조건절에 반드시 사용하여 Index Range Scan을 해야 한다.
- 조건절에 항상 사용하거나, 자주 사용하는 컬럼을 선정한다.
- ‘=’ 조건으로 자주 조회하는 컬럼을 앞쪽에 둔다.

## 3.4.3 스캔 효율성 이외의 판단 기준

- 수행빈도
    - 가장 중요한 기준
    - 자주 수행하지 않는 SQL이면 인덱스 스캔 과정에 비효율이 있어도 큰 문제가 아닐 수 있다.
    - 수행 빈도가 매우 높은 SQL이면 최적의 인덱스를 구성 해줘야 한다.
- 업무상 중요도
- 클러스터링 팩터
- 데이터량
    - 데이터가 적으면 인덱스가 필요 없다. Table Full Scan으로 충분히 빠르다.
    - 인덱스 많이 만들어도 큰 문제가 안 된다.
    - 따라서 데이터가 적으면 심각하게 고민할 이유가 없다.
    - 반대로 초대용량 테이블은 INSERT도 많다.
    - 초당 DML 발생량은 트랜잭션 성능(TPS)에 직접적인 영향을 준다.
    - 인덱스를 하나라도 줄였을 때 시스템에 미치는 영향은 적지 않다.
- DML 부하(=기존 인덱스 개수, 초당 DML 발생량, 자주 갱신하는 컬럼 포함 여부 등)
- 저장 공간
- 인덱스 관리 비용 등

## 3.3.4 공식을 초월한 전략적 설계

- 모든 패턴마다 인덱스를 만들 수는 없다
- 핵심적인 액세스 경로 한 두개를 전략적으로 선택하여 최적 인덱스를 설계하고, 나머지 액세스 경로는 약간의 비효율이 있더라도 목표 성능을 만족하는 수준으로 인덱스를 구성할 수 있어야 한다.
- 이에 대한 선택과 전략적 판단 근거도 가지고 있어야 한다.
- 가계약 테이블 p.236

## 3.4.5 소트 연산을 생략하기 위한 컬럼 추가

- 인덱스는 항상 정렬 상태를 유지하므로 ORDER BY, GROUP BY를 위한 소트 연산을 생략할 수 있게 해준다.
- 조건절에 사용하지 않는 컬럼이더라도 소트 연산을 생략할 목적으로 인덱스 구성에 포함시킴으로써 성능 개선을 도모할 수 있다.
- `=`조건절 컬럼은 ORDER BY 절에 없더라도 인덱스 구성에 포함 가능하다.
    - 위치는 상관 없다.
- `=`이 아닌 조건절 컬럼들은 반드시 ORDER BY 컬럼보다 뒤쪽에 두어야 소트 연산을 생략할 수 있다.
- I/O를 최소화하면서도 소트 연산 생략 공식
    - `=` 연산자로 사용한 조건절 컬럼 선정
    - ORDER BY 절에 기술한 컬럼 추가
    - `=` 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정

### IN 조건을 ‘=’이 아니다.

- 소트 연산을 생략하려면 IN 조건절이 IN-List Iterator 방식으로 풀려서는 안된다.
- 즉 IN 조건절을 인덱스 액세스 조건으로 사용하면 안된다.
- 필터 조건으로 사용해야 한다.
- ORDER BY 컬럼 뒤쪽에 분포시키자.

## 3.4.6 결합 인덱스 선택도

- 인덱스 생성 여부시 선택도(Selectivity) 가 낮아야 한다.
- 카디널리티(선택도 * 총 레코드 수) 를 구한다.

### 컬럼 순서 결정 시, 선택도 이슈

- 결합 인덱스 구성 시 선택도가 낮은 컬럼을 앞에 두든 뒤에 두든 둘다 인덱스 조건이므로 인덱스 스캔 범위는 동일하다.
- 중요한 것은 항상 사용하는 컬럼을 앞쪽에 두고 그 중 `=` 조건을 앞쪽에 위치시키는 것이다.
- 결론적으로 선택도는 매우 중요하지만 컬럼간 순서를 결정할 때는 필수조건 여부, 연산자 형태가 더 중요하다.

## 3.4.7 중복 인덱스 제거

- 포함 관게시 '완전 중복' 이다. 모든 컬럼을 가지는 하나의 인덱스만 있으면 된다.
- 선두 컬럼이 같고 선두 컬럼의 카디널리티가 매우 낮으면 사실상 중복이다. 이를 '불완전 중복' 이라고 한다. 이런 경우에도 1개만 만들면된다.
- 실습(p.245 ~ p.249)

## 3.4.8 인덱스 설계도 작성

- 시스템 전체 효율을 고려해야 한다.
- 인덱스 설계 전체를 조망할 수 있는 설계도면이 필수이다(인덱스 설계도)
- 실제 발생하는 액세스 유형을 모두 조사하는 과정 필요
- 인덱스 설계 전에 파티션 설계를 먼저 진행하거나 최소한 병행해야 제대로 된 인덱스 전략 수립 가능