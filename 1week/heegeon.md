## 1. SQL 처리 과정과 I/O

## 1.1 SQL 파싱과 최적화
### 구조적, 집합적, 선언적 질의 언어
- SQL은 'Structured Query Language'의 약자로, 구조적 질의 언어라고 한다.
- 사용자가 SQL문을 작성하면 옵티마이저가 이를 분석하고 DBMS 내부에서 프로시저를 작성하는데 이를 `SQL 최적화`라고 한다.

### 1.1.2 SQL 최적화
1. 사용자로부터 SQL을 전달받으면 SQL 파서가 파싱을 진행한다.
    - 파싱 트리 생성 -> Synctax 체크 -> Semantic 체크 
2. 옵티마이저가 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행경로를 생성하여 비교한 후 비용이 가장 적은 실행계획을 선택한다. 
3. 로우 소스 생성
    - 옵티마이저가 선택한 실행계획을 실행 가능한 코드나 프로시저 형태로 포맷팅한다.

### 옵티마이저 힌트
- 옵티마이저가 생성한 실행계획이 사용자가 원하는 실행계획과 다를 경우 사용자가 직접 실행계획을 제어할 수 있는 방법이다.
```sql
    SELECT /*+ INDEX(EMP EMP_IDX) */ * 
    FROM EMP 
    WHERE EMPNO = 1234;
```

- 아래와 같은 방법도 있지만 줄바꿈 오류가 발생할 수 있기 때문에 가급적 사용하지 않는다.
```sql
    SELECT --+ INDEX(EMP) * 
    FROM EMP 
    WHERE EMPNO = 1234;
```

- 힌트 안에 인자를 나열할 때는 콤바를 사용할 수 있지만 힌트와 힌트 사이에는 사용하면 안 된다.
```sql
-- 힌트 안의 인자 나열
    SELECT /*+ INDEX(EMP EMP_IDX) */ * 

-- 힌트와 힌트 사이에 콤마 사용 불가능
    SELECT /*+ INDEX(EMP EMP_IDX), INDEX(DEPT DEPT_IDX) */ *
```

- 테이블을 지정할 떄 스키마명까지 명시하면 안 된다.
```sql
-- 틀린 예
    SELECT /*+ INDEX(SCOTT.EMP) */ *
  
-- 올바른 예
    SELECT /*+ INDEX(EMP) */ *
```

- FROM 절 테이블명 앞에 ALIAS를 지정했다면 힌트에도 반드시 ALIAS를 사용해야 한다.
```sql
-- 틀린 예
    SELECT /*+ INDEX(EMP) */ *
    FROM EMP EMP_IDX;

-- 올바른 예
    SELECT /*+ INDEX(EMP_IDX) */ *
    FROM EMP EMP_IDX;
```

- 힌트를 통해 옵티마이저의 방향성을 정해준다면 자율적 판단을 배제하도록 빈틈없이 지정해주어야 한다.

## 1.2 SQL 공유 및 재사용
### 소프트 파싱 vs 하드 파싱
SQL에는 `SGA` 라는 공유 메모리 영역이 존재하는데 이 안에는 SQL 최적화 과정을 거쳐 생성된 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간인 `라이브러리 캐시`가 존재한다.
- `소프트 파싱` : 실행된 SQL을 캐시에서 찾아서 바로 실행단계로 넘어가는 것.
- `하드 파싱` : 캐시에서 SQL을 찾지 못하고 최적화와 로우 소스 생성 과정을 거쳐서 실행단계로 넘어가는 것.

하드 파싱은 하나의 쿼리를 수행하는 데에 수많은 후보군을 도출하고 효율성을 판단하는 과정에서 많은 시간이 소요되기 때문에 소프트 파싱을 통해 최적화된 실행계획을 재사용하는 것이 효율적이다.

### 바인드 변수의 중요성
#### 이름없는 SQL 문제
SQl은 따로 이름이 없기 때문에 전체 SQL 텍스트가 이름 역할을 한다. 따라서 텍스트 중 작은 부분이라도 수정되면 그 순간 다른 객체가 새로 탄생하는 구조이다.

#### 공유 가능 SQL
라이브러리 캐시에서 SQL을 찾기 위해 사용하는 키 갑이 SQL 문 그 자체이르모 바인드 변수를 사용하면 SQL 문을 공유할 수 있다.

바인드 변수는 파라미터 Driven 방식으로 SQL을 작성하는 방법이다.
바인드 변수를 사용하면 하드파싱이 최초 한 번만 발생하여 SQL 하드파싱으로 인한 부하를 줄일 수 있고, SQL 캐시를 통해 재사용할 수 있어 성능을 향상시킬 수 있다.

## 1.3 데이터 저장 구조 및 I/O 메커니즘
### SQL이 느린 이유
SQL이 느린 이유는 디스크 I/O 때문이다.
프로세스가 디스크에서 데이터를 읽어야 할 땐 CPU를 OS에 반화하고 Waiting 상태에서 I/O가 끝나기를 기다린다. 일해야 할 프로세스가 대기 큐에서 잠을 자고 있기 때문에 I/O가 많으면 성능이 느려진다.

Single Block 기준으로 I/O CAll 속도는 평균 10ms쯤 된다. 만약 SQL이 Single Block 방식으로 10,000 블록을 읽는다면 약 10초가 걸린다는 것이다. 수많은 프로세스에 의해 동시다발적으로 발생하는 I/O Call 때문에 디스크 경합이 심해지고 그만큼 대기 시간도 늘어난다.

### 데이터베이스 저장 구조
- 블록 : 데이터를 읽고 쓰는 단위
- 익스텐트 : 공간을 확장하는 단위, 연속된 블록 집합
- 세그먼트 : 데이터 저장공간이 필요한 오브젝트
- 테이블스페이스 : 세그먼트를 담는 컨테이너
- 데이터파일 : 디스크 상의 물리적인 OS 파일

### 블록 단위 I/O
DBMS가 데이터를 읽고 쓰는 단위는 Block이다. 특정 레코드 하나를 읽고 싶더라도 블록 전체를 읽어오게 된다.
오라클은 기본적으로 8KB 크기의 블록을 사용하므로 1Byte를 읽기 위해서도 8KB를 읽어오게 된다.

### 시퀀셜 엑세스 vs 랜덤 엑세스
테이블 또는 인덱스 블록을 액세스하는 방식에는 시퀀셜 엑세스와 랜덤 엑세스가 있다.

시퀀셜 액세스는 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식이다. 인덱스 리프 블록은 앞뒤를 가리키는 주소값을 통해 논리적으로 서로 연결돼 있다.
테이블 간에는 서로 논리적인 연결고리를 가지고 있지 않은데 이런 경우를 위해 오라클은 세그먼트에 할당된 익스텐트 목록을 세그먼트 헤더에 맵으로 관리한다. 익스텐트 맵은 각 블록의 첫 번째 익스텐스 주소값을 가지고
각 익스텐트의 첫 블록 뒤에 연속해서 블록을 읽어오는 방식이다.

랜덤 액세스는 블록을 읽을 때 논리적인 순서와 상관없이 블록을 읽는 방식이다.

### 논리적 I/O vs 물리적 I/O
자주 읽는 블록을 매번 디스크에서 읽은 것은 매우 비효율적이다. 따라서 SQL을 저장하는 `라이브러리 캐시`도 중요하지만 데이터를 저장하는 `DB 버퍼캐시`도 SGA에 포함되며 중요한 파트이다.

논리적 블록 I/O는 SQL을 처리하는 과정에서 발생한 총 블록 I/O를 말한다. 일반적으로 메모리 상의 버퍼 캐시를 경유하기 떄문에 메모리 I/O가 논리적 I/O라고 생각해도 무방하다.

물리적 블록 I/O는 디스크에서 발생한 총 블록 I/O를 말한다. SQL 처리 도중 읽어야 할 블록을 버퍼캐시에서 찾지 못할 때만 디스크를 액세스하므로 논리적 블록 I/O 중 일부를 물리적으로 I/O한다.

논리적 I/O는 전지적 신호이지만 물리적 I/O는 액세스 암에 의해 물리적 자굥이 발생하므로 물리적 I/O가 약 10,000배쯤 느리다.
>Q. 논리적 I/O와 메모리I/O의 차이? (52p)

### 버퍼캐시 히트율(BCHR)
버퍼캐시 히트율은 읽은 전체 블록 중에서 물리적인 디스크 I/O를 수반하지 않고 곧바로 메모리에서 찾은 비율이다.

애플리케이션 시스템 레벨에서 평균 99%의 히트율을 달성해야 시스템 부하를 줄일 수 있다.

`BCHR = (1 - (Physical I/O / Logical I/O)) * 100`

공식을 통해 물리적 I/O가 성능을 결정하지만, 실제 SQL 성능을 향상하기 위해서는 물리적 I/O가 아닌 논리적 I/O를 줄여야 한다는 것을 알 수 있다.

`Physical I/O = Logical I/O * (100 - BCHR)`

데이터를 읽는 상황에서 조건절에 같은 변수값을 입력하면 항상 논리적 I/O가 일정하기 때문에 물리적 I/O는 BCHR에 의해 결정된다.
따라서 논리적 I/O를 줄이는 것이 물리적 I/O를 줄이는 길이다. 즉, 논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것이 SQL 튜닝이다.

그렇다면 논리적 I/O를 어떻게 줄일 수 있을까? 바로 SQL 튜닝을 통해 총 블록 개수를 줄이는 것이다.

요약하면, BCHR 공식을 이루는 물리적 I/O는 통제 불가능한 외생변수이다. 물리적 I/O는 버퍼캐시 크기를 늘리는 것 외에는 방법이 없다.
하지만 논리적 I/O는 SQL 튜닝을 통해 줄일 수 있다. 따라서 SQL 튜닝을 통해 논리적 I/O를 줄이는 것이 물리적 I/O를 줄이는 길이다.

한 가지 주의해야 할 점은 BCHR이 높다고 반드시 효율적인 SQL은 아니라는 것이다. 같은 블록을
여러차례 읽으면 BCHR은 높아지기 때문이다.

### Single Block I/O vs Multi Block I/O
한 번에 한 블록씩 요청해서 메모리에 적재하는 방식을 `Single Block I/O`라고 하며
캐시에서 찾지 못한 특정 블록을 읽으려고 I/O Call을 할 때 디스크 상에 그 블록과 인접한 블록들을 한꺼번에 읽어 캐시에 미리 적재하는 기능을 `Multi Block I/O`라고 한다.
여기서 인접한 블록이란 같은 익스텐트에 속한 블록을 말한다. 이는 Multi Block I/O가 익스텐스 경계를 넘지는 못한다는 것을 의미한다.
- 익스텐트에 20개의 블록이 담겨있고 I/O 단위가 8이라고 할 때, 세 번째 I/O는 4개의 블록만 읽게 된다.

인덱스를 이용할 때는 기본적으로 인덱스와 테이블 블록 모두 Single Block I/O 방식을 사용한다.
반대로 많은 데이터 블록을 읽는 테이블 전체 스캔은 Multi Block I/O 방식을 사용한다.

### Table Full Scan vs Index Range Scan
- Table Full Scan : 테이블에 속한 블록 전체를 읽는 방식
- Index Range Scan : 인덱스에서 일정량을 스캔하면서 얻은 ROWID로 테이블 레코드를 찾아가는 방식
   - ROWID는 테이블 레코드가 디스크에 저장된 물리적인 주소값을 가리킨다.

SQL 튜닝을 하면 반드시 인덱스 스캔을 사용해야 하는 것은 아니다. 오히려 인덱스 스캔이 느릴 수 있으며 테이블 전체 스캔이 더 빠를 수도 있다.

### 캐시 탐색 매커니즘
Direct Path I/O를 제외한 모든 블록 I/O는 메모리 버퍼캐시를 경유한다.

버퍼캐시에서 블록을 찾을 때는 해시 알고리즘을 통해 버퍼 헤더를 찾고, 거기서 얻은 포인터로 버퍼 블록을 액세스하는 방식을 사용한다.

버퍼캐시는 SGA의 공유자원으로서 여러 프로세스가 동시에 접근할 수 있기 때문에 내부에서
한 프로세스씩 순차적으로 접근할 수 있도록 직렬화 매커니즘이 필요하다.

이러한 직렬화 매커니즘을 'LATCH'라고 한다.
해시 체인 앞쪽에 잠금장치를 두고 열쇠를 가진 프로세스만이 버퍼 블록에 접근할 수 있도록 하는 방식이다.

### 버퍼 Lock
래치를 해체하고 버퍼 블록 데이터를 읽거나 쓰는 동안 후행 프로세스와 경합이 발생하는 것을 방지하기 위해 버퍼블록 자체에도 잠금장치인 `버퍼 lock`을 사용한다.

