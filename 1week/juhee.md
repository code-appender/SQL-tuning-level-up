## 1. SQL파싱과 최적화

SQL : Structured Query Language ⇒ 구조적 질의 언어 이다.

옵티마이저가 프로그래밍을 대신해준다.

### SQL 최적화

1. SQL 파싱
    1. 파싱 트리 생성
    2. Syntax 체크
    3. Sementic 체크
2. SQL 최적화
    1. 옵티마이저가 생성한것중 최적인것을 선택한다.
3. 로우 소스 생성(로우소스 생성기)
    1. 옵티마이저가 선택한 실행 경로를 실제 실행가능한 프로시저 형태로 포맷팅 한다.

### SQL 옵티마이저

사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 액세스 경로를 선택해주는 DBMS의 핵심 엔진이다.

### 실행 계획과 비용

옵티 마이저가 실행계획을 선택하는 근거는? cost(비용), 쿼리를 수행하는 동안 발생할것으로 예상되는 I/O횟수 또는 예상 소요시간을 표현한것이다.

cost는 예상치이기에 실제 실행시에는 달라질 수 있다.

### 옵티마이저 힌트

개발자가 직접 더 효율적인 액세스 경로를 찾아낼 수도 있다. 이럴때 옵티마이저 힌트를 사용해서 데이터 액세스 경로를 바꿀수 있다.

## 2. SQL공유 및 재사용

### 소프트 파싱 vs 하드파싱

소프트 파싱 : 캐시에서 찾아 곧바로 실행단계 까지 넘어가는 것

하드 파싱 : 실패해 최적화 및 로우 소스 생성 단계 까지 모두 거치는 것

왜 최적화를 하면 하드 할까? ⇒ 모든 경우의 수를 확인하느라 CPU를 많이 소비한다.  ⇒ 이래서 소프트 파싱이 필요하다.

## 3. 데이터 저장 구조 및 I/O 메커니즘

### 1. SQL이 느린이유

십중팔구 I/O 때문이다.

### 2. 데이터 베이스 저장구조

블록 : 데이터를 읽고 쓰는 단위

익스텐트 : 공간을 확장하는 단위, 연속된 블록 집합

세그먼트 : 데이터 저장공간이 필요한 오브젝트

테이블 스페이스 : 세그먼트를 담는 콘테이너

데이터 파일 : 디스크 상의 물리적인 OS파일

### 3. 블록단위 I/O

블록 단위로 DBMS가 데이터를 읽고 쓴다.

### 4. 시퀀셜 액세스 vs 랜덤 엑세스

시퀀셜 액세스 : 논리적, 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식이다. (이때 시퀀셜하게 연결하기 위해 오라클은 세크먼트 헤더에 맵으로 관리한다.)

랜덤 액세스: 논리적,물리적 순서 따르지 않고 레코드 하나를 익기 위해 한블록씩 접근하는 방식

### 5. 논리적 I/O vs 물리적 I/O

DB버퍼 캐시 : 데이터를 캐싱한다. (I/O가 성능을 결정하기에 중요 기능이다.)

반복적인 I/O call을 줄인다.

논리적 블록 I/O : SQL을 처리하는 과정에 발생한 총 블록 I/O

물리적 블록 I/O : 디스크에서 발생한 총 블록 I/O

SQL을 수행하면서 읽은 총 블록 I/O가 논리적 I/O이다.

DB버퍼 캐시에서 블록을 찾지 못해 디스크에서 읽은 블록 I/O 가 물리적 I/O이다.

논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것이  곧 SQL튜닝이다.

버퍼캐시히트율(BCHR)이 SQL성능을 좌우 하지만, 높다고 해서 효율적인 SQL을 의미하는것은 아니다.

### Single Block I/O vs Multiblock I/O

모든 데이터를 캐시에 적재할 수 없다.

Single Block I/O : 한번에 한 블럭씩 요청해서 메모리에 적재하는 방식

Multiblock I/O  : 한번에 여러 블록씩 요청해서 메모리에 적재하는 방식

### Table Full Scan vs Index Range Scan

Table Full Scan : multiblock io + sequential access

Index Range Scan : single block io + random access

인댁스를 맹신 하지 마라 + 데이터가 일정 수준이 넘어가면 테이블 풀 스캔이 낫다.

### 캐시 탐색 메커니즘

직렬화 메커지즘에 의한 캐시 경합을 줄이려면, SQL 튜닝을 통해 쿼리 일량(논리적 I/O)를 줄여야 한다.