# 3. 인덱스 튜닝

# 3.1 테이블 액세스 최소화

> SQL 튜닝은 랜덤 I/O와의 전쟁이다. 튜닝 기법도 랜덤 I/O 최소화에 맞춰져있다.
>

## 3.1.1 테이블 랜덤 액세스

### 인덱스 ROWID는 물리적 주소? 논리적 주소?

- 인덱스를 이용해 테이블을 액세스하는 SQL 실행계획을 살펴보자.
    - 인덱스를 스캔한 후에 반드시 테이블을 액세스한다.
- 인덱스를 스캔하는 이유는, 검색 조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾고 거기서 테이블 레코드를 찾아가기 위한 주소값, 즉 ROWID를 얻으려는 데 있다.
- 인덱스 ROWID는 물리적으로 직접 연결되지 않고 테이블 레코드를 찾아가기 위한 논리적 주소 정보를 담고 있기 때문에 논리적 주소다.

### 메인 메모리 DB와 비교

- 잘 튜닝된 OLTP성 데이터베이스 시스템이라면 버퍼캐시 히트율 99% 이상이다.
- 디스크를 경유하지 않고 메모리에서 읽는다는 뜻인데, 메모리 DB만큼 빠르지 않다.
    - 특히 대량 데이터를 인덱스로 액세스할 때는 엄청난 차이가 난다. 왜?
- 테이블 블록이 수시로 버퍼캐시에서 밀려 났다가 다시 캐싱되며, 그때마다 다른 공간에 캐싱되기 때문에 인덱스에서 포인터로 직접 연결할 수 없는 구조다.
- 메모리 주소 정보가 아닌 디스크 주소 정보를 이용해 해시 알고리즘으로 버퍼 블록을 찾아간다.
- 일반 DBMS에서 인덱스 ROWID를 이용한 테이블 액세스가 생각만큼 빠르지 않은 이유다.

### I/O 메커니즘 복습

- DBA(= 데이터 파일 번호 + 블록 번호)는 디스크 상에서 블록을 찾기 위한 주소 정보다.
- I/O 성능을 높이려면 버퍼캐실르 활용해야 하고, 블록을 읽을 때는 디스크로 가기전에 버퍼캐시부터 찾아본다.(look aside) 읽고자 하는 DB를 해시 함수에 입력해서 해시 체인을 찾고 거기서 버퍼 헤더를 찾는다.
- 거기서 얻은 포인터로 버퍼 블록을 찾아간다.
- 인덱스로 테이블 블록을 액세스할 때 과정은
    - 리프 블록에서 읽은 ROWID를 분해해서 DBA 정보 얻는다.
    - 테이블 Full Scan 할 때는 익스텐트 맵을 통해 읽을 블록들의 DBA 정보를 얻는다.
- 모든 데이터가 캐싱 되어 있더라도 매번 DBA 해싱과 래치 획득 과정을 반복해야 한다.
- 동시 액세스가 심할 때는 캐시버퍼 체인 래치와 버퍼 Lock에 대한 경합 발생한다.
- 인덱스 ROWID를 이용한 테이블 액세스는 고비용 구조다.

## 3.1.2 인덱스 클러스터링 팩터

- 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다.
- CF가 좋은 컬럼에 생성한 인덱스는 검색 효율 매우 좋다.
- 예를 들어, 거주지역 = ’제주’에 해당하는 고객 데이터가 물리적으로 근접해 있으면 흩어져 있을 때보다 데이터를 찾는 속도가 빠르다.
- 블록 I/O 발생량에 차이가 없는데, 오라클은 래치 획득과 해시 체인 스캔 과정을 거쳐 어렵게 찾아간 테이블 블록에 대한 포인터를 바로 해제하지 않고 일단 유지한다. 이를 `버퍼 Pinning`
    - 직전과 같은 테이블 블록을 가리키면 래치 획득과 해시 체인 스캔 과정을 생략한다.
    - 논리적은 블록 I/O 과정을 생략할 수 있는 것이다.

## 3.1.3 인덱스 손익분기점

인덱스 ROWID를 이용한 테이블 액세스는 생각보다 고비용 구조다.

읽어아 햘 데이터가 일정량을 넘는 순간, 테이블 전체를 스캔하는 것보다 오히려 느려진다.

Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점을 `인덱스 손익분기점`이라고 부른다.

- Table Full Scan은 성능이 일정하다.
- 인덱스를 이용해 테이블을 액세스 할 때는 전체 1,000만 건 중 몇 건을 추출하느냐에 따라 성능이 크게 달라진다.
    - 테이블 랜덤 액세스 때문이다.
- 인덱스를 이용한 테이블 액세스가 더 느린 요인은?
    - 테이블 풀 스캔은 시퀀셜 액세스인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 랜덤 액세스 방식이다.
    - 테이블 풀 스캔은 Multiblock I/O인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 Single Block I/O 방식이다.

모든 문제를 인덱스로 해결하려 해선 안 된다.

인덱스는 큰 테이블에서 아주 적은 일부 데이터를 빨리찾고자 할 때 주로 사용한다.

## 3.1.4 인덱스 컬럼 추가

- 인덱스 구성 변경하기 쉽지 않다.
- 인덱스를 새로 만드는 것도 배보다 배꼽이 더 커지게 된다.
- 인덱스 관리 비용이 증가함은 물론 DML 부하에 따른 트랜잭션 성능 저하가 생길 수 있다.
- 인덱스에 컬럼을 추가하는 것만으로 큰 효과를 얻을 수 있다.
    - 인덱스 스캔량은 줄지 않지만, 테이블 랜덤 액세스 횟수를 줄여주기 때문이다.

## 3.1.5 인덱스만 읽고 처리

- 테이블 액세스 단계 필터 조건에 의해 버려지는 레코드가 많을 때, 인덱스에 컬럼을 추가함으로써 얻는 성능 효과를 살펴보았다.
- 그런데 테이블 랜덤 액세스가 아무리 많아도 필터 조건에 의해 버려지는 레코드가 거의 없다면 인덱스 컬럼 추가로 해결할 수 없다.

### Covered 인덱스

- 쿼리에 사용된 컬럼을 모두 인덱스에 추가해서 테이블 액세스가 아예 발생하지 않게 하는 방법
- 효과는 매우 좋지만, 추가해야 할 컬럼이 많아 실제 적용하기 곤란한 경우도 많다.

### Include 인덱스

```sql
create index emp_x01 on emp (deptno) include (sal)

create index emp_x02 on emp(deptno, sal)
```

- emp_x02 인덱스는 두 컬럼 모두 루트와 브랜치 블록에 저장한다.
    - 수직적 탐색에 사용할 수 있다.
- emp_x01 인덱스는 sal 컬럼을 리프 블록에만 저장한다.
    - 수직적 탐색에는 deptno 만 사용, 수평적 탐색에는 sal 컬럼도 필터 조건으로 사용.
    - sal 컬럼은 테이블 랜덤 액세스 횟수를 줄이는 용도로만 사용한다.

## 3.1.6 인덱스 구조 테이블

- 랜덤 액세스 발생하지 않도록 테이블을 인덱스 구조로 생성
- 테이블 블록에 있어야 할 데이터를 인덱스 리프 블록에 모두 저장한다.
- 정렬 상태를 유지하며 데이터를 입력한다.
- 예를 들면, 영업사원이 100명, 일별 실적을 집계하는 테이블이 존재하고 한 블록에 100개 레코드가 담긴다. 매일 한 블록씩 1년이면 365개 블록이 생긴다.
- 인덱스를 사용한다면, 사원 마다 랜덤 액세스 방식으로 365개 테이블 블록을 읽어야 한다. 클러스터링 팩터가 매우 안 좋으므로 조회 건수만큼 블록 I/O가 발생한다.
- 사번이 첫 번째 정렬 기준이 되도록 인덱스 구조 테이블을 구성한다면, 네 개 블록만 읽고 처리할 수 있다.

## 3.1.7 클러스터 테이블

### 인덱스 클러스터 테이블

- 클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조다.
    - 한 블록에 담을 수 없을 때는 새로운 블록을 할당해서 클러스터 체인으로 연결한다.
- 여러 테이블 레코드를 같은 블록에 저장할 수 있는데 다중 테이블 클러스터 라고 부른다.

### 해시 클러스터 테이블

- 인덱스를 사용하지 않고 해시 알고리즘을 사용해 클러스터를 찾아간다.

---

# 3.2 부분범위 처리 활용

테이블 랜덤 액세스로 인한 인덱스 손익분기점의 한계를 극복하는 방법

인덱스로 액세스할 대상 레코드가 아무리 많아도 빠른 응답속도를 낼 수 있다.

## 3.2.1 부분범위 처리

- DBMS가 클라이언트에게 데이터를 전송할 때 일정량씩 나누어 전송한다.
- Fetch Call을 받기 전까지 그대로 멈춰 서서 기다린다.

## 3.2.3 OLTP 환경에서 부분범위 처리에 의한 성능개선 원리

- 인덱스로 소트 연산을 생략할 수 없을 때,
    - 인덱스를 게시판구분코드 + 등록일시 순으로 구성하면 Sort Order By 연산을 생략할 수 있다.

---

# 3.3 인덱스 스캔 효율화

## 3.3.1 인덱스 탐색

- `수직적 탐색`은 스캔 시작점을 찾는 과정이다.
- 책을 참고.

## 3.3.2 인덱스 스캔 효율성

- 읽은 블록 수 대비 얻은 레코드 수
- 얻은 레코드가 열 개인데, 7,463개 블록 (cr=7463)
    - 한 블록당 평균 500개 레코드가 담긴다고 가정하면 7,463 * 500개 레코드를 읽은 셈이다.
    - 그 많은 데이터를 읽고 열 개를 얻었다니 매우 비효율이다.