# 3. 인덱스 튜닝

## 3.1 테이블 액세스 최소화

### ROWID
SQL이 참조하는 컬럼을 인덱스가 모두 포함하는 경우가 아니면, 인덱스를 스캔한 후에 반드시 테이블을 액세스한다.
`TABLE ACCESS BY INDEX ROWID` 가 이에 해당한다.

인덱스를 스캔하는 이유는 검색 조건을 만족하는 소량의 데이터를 인덱스에서 빠르게 찾고 그 안에서 ROWID(테이블 레코드 주소값)을 얻으려는 데에 있다.

이 ROWID는 물리적 주소보다는 논리적 주소에 가깝다. 물리적으로 직접 연결되지 않고 테이블 레코드를 찾아가기 위한 논리적 주소 정보를 담고 있기 떄문이다.

### 메인 메모리 DB와 비교
메인 메모리 DB란 데이터를 모두 메모리에 로드해 놓고 메모리를 통해서만 I/O를 구생하는 DB이다. 잘 튜닝된 OLTP성 데이터베이스 시스템이 버퍼캐시 히트율 99%를 달성해도
메인 메모리 DB만큼 빠르지는 않다. 이는 아키텍쳐부터 차이가 나기 떄문이다.

메인 메모리 DB의 경우 인스턴스를 기동하면 디스크에 저장된 데이터를 버퍼캐시로 로딩하고 이어서 인덱스를 생성한다. 이때 인덱스는 오라클처럼 디스크 상의 주소정보를 갖는 게 아니라 메모리상의 주소정보
즉, 포인터를 가진다. 따라서 인덱스를 경유해 테이블을 액세스하는 비용이 오라클과는 비교할 수 없을 정도로 낮다.

오라클은 테이블 블록이 수시로 버퍼캐시에서 밀려났다가 다시 캐싱되며 그때마다 다른 공간에 캐싱되기 때문에 인덱스에서 포인터로 직접 연결할 수 없는 구조이다.
즉, 메모리 주소 정보가 아닌 디스크 주소 정보(DBA)를 이용해 해시 알고리즘으로 버퍼 블록을 찾아간다. 

다시 정리하면, ROWID에 담겨있는 DBA정보로 테이블 블록 정보를 확인하고 테이블 블록을 버퍼캐시에서 먼저 찾아본 후 없다면 디스크에서 읽어들인 뒤 버퍼캐시에 적재 후 조회한다.
설령 모든 데이터가 캐싱돼 있더라도 테이블 레코드를 찾기 위해 매번 DBA 해싱과 래치 획득 과정을 거쳐야 한다. 따라서 INDEX ROWID는 고비용 구조이다.

### 인덱스 클러스터링 팩터
클러스터링 팩터는 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다. <br>
CF가 좋은 컬럼에 생성한 인덱스는 검색 효율이 매우 좋다. CF가 가장 좋은 상황에서 블록 I/O는 `풀 스캔 / 인덱스에 담긴 테이블 레코드 수`로 줄어든다.

### 인덱스 손익분기점
인덱스 ROWID를 이용한 테이블 액세스는 생각보다 고비용 구조이기 때문에 읽어야 할 데이터가 일정량을 넘는 순간 테이블 전체를 스캔하는 것보다 느려진다.

두 가지를 고려해야 한다.
- Table Full Scan은 시퀀셜 액세스인 반면 인덱스 ROWID를 이용한 테이블 액세스는 랜덤 액세스 방식이다.
- Table Full Scan은 Multiblock I/O인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 Single Block I/O이다.

### 인덱스 컬럼 추가
테이블 액세스 최소화를 위해 가장 일반적으로 사용하는 튜닝 기법은 인덱스에 컬럼을 추가하는 것이다.
인덱스 구성 자체를 변경하는 것은 기존 인덱스를 사용하는 SQL이 존재하기 때문에 어렵고 새로운 인덱스를 만들다보면 관리 비용이 증가한다. 따라서 인덱스에 필요한 컬럼을
추가하게 되면 인덱스 스캔량이 줄지는 않지만 테이블 랜덤 액세스 횟수를 줄일 수 있다.

### 인덱스 구조 테이블(IOT)
인덱스 구조 테이블은 랜덤 액세스가 아예 발생하지 않도록 인덱스 리프 블록에 데이터 블록에 있어야 할 데이터를 모두 저장한다.<br>
이는 인위적으로 클러스터링 팩터를 좋게 만다는 방법 중 하나이며 항상 시퀀셜 방식을 사용한다.

### 클러스터 테이블
#### 1. 인덱스 클러스터 테이블
인덱스 클러스터 테이블은 클러스터 키값이 같은 레코드를 한 블록에 모아 저장하는 구조이다.<br>

일반 테이블에 생성한 인덱스 레코드는 테이블 레코드와 1:1 대응 관계를 가지지만 클러스터 인덱스는 1:M 관계를 갖는다. 따라서 클러스터 인덱스의 키 값은 항상 Unique하다. <br>
클러스터에 도달해서는 시퀀셜 방식으로 스캔하기 때문에 넓은 범위를 읽더라도 비효율이 없다는 것이 핵심원리이다.

## 3.2 부분범위 처리 활용
부분범위 처리란 전체 쿼리 결과집합을 쉼 없이 연속적으로 전송하지 않고 사용자로부터 Fetch Call이 있을 때마다 일정량씩 나누어 전송하는 것을 말한다.<br>

### Array Size 조정을 통한 Fetch Call 최소화
Array Size를 조정하면 Fetch Call을 최소화할 수 있다. 하지만 Array Size를 무작정 늘리면 안된다. 
Array Size가 너무 크면 메모리를 많이 사용하게 되고, 너무 작으면 Fetch Call이 빈번해져 성능이 떨어진다.

### 멈출 수 있어야 의미있는 부분범위 처리
부분범위 처리는 사용자가 멈출 수 있어야 의미가 있다.<br>

그런데 클라이언트와 DB 서버 사이에 WAS, AP 서버 등이 존재하는 n-Tier 아키텍처에서는 클라이언트가 특정 DB 커넥션을 독점할 수 없다.<br>
단위 작업을 마치면 DB 커넥션을 곧바로 커넥션 풀에 반환해야 하므로 그 전에 ㄴSQL 조회 결과를 모두 전송하고 커서를 닫아야 하기 때문에 조금씩 나누기 어렵다.
하지만 이를 극복하는 방법도 있다. -> 5.3절

